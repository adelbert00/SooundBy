var Je = Object.defineProperty;
var Ke = (n, e, t) => e in n ? Je(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : n[e] = t;
var l = (n, e, t) => (Ke(n, typeof e != "symbol" ? e + "" : e, t), t);
import { unref as Ze, getCurrentScope as et, onScopeDispose as tt, computed as ve, ref as C, watch as G, isRef as Ie, shallowRef as ue, watchEffect as ge, defineComponent as Y, openBlock as J, createElementBlock as K, Fragment as oe, createElementVNode as D } from "vue";
var Ae;
const be = typeof window < "u", nt = (n) => typeof n == "string", rt = () => {
};
be && ((Ae = window == null ? void 0 : window.navigator) == null ? void 0 : Ae.userAgent) && /iP(ad|hone|od)/.test(window.navigator.userAgent);
function m(n) {
  return typeof n == "function" ? n() : Ze(n);
}
function Le(n, e = !1, t = "Timeout") {
  return new Promise((r, i) => {
    setTimeout(e ? () => i(t) : r, n);
  });
}
function it(n) {
  return n;
}
function at(n, ...e) {
  return e.some((t) => t in n);
}
function de() {
  const n = [], e = (i) => {
    const a = n.indexOf(i);
    a !== -1 && n.splice(a, 1);
  };
  return {
    on: (i) => (n.push(i), {
      off: () => e(i)
    }),
    off: e,
    trigger: (i) => {
      n.forEach((a) => a(i));
    }
  };
}
function Ce(n) {
  return et() ? (tt(n), !0) : !1;
}
function fe(n) {
  return typeof n == "function" ? ve(n) : C(n);
}
function ye(n, e = !1) {
  function t(c, { flush: h = "sync", deep: g = !1, timeout: v, throwOnTimeout: N } = {}) {
    let _ = null;
    const q = [new Promise((M) => {
      _ = G(n, (z) => {
        c(z) !== e && (_ == null || _(), M(z));
      }, {
        flush: h,
        deep: g,
        immediate: !0
      });
    })];
    return v != null && q.push(Le(v, N).then(() => m(n)).finally(() => _ == null ? void 0 : _())), Promise.race(q);
  }
  function r(c, h) {
    if (!Ie(c))
      return t((z) => z === c, h);
    const { flush: g = "sync", deep: v = !1, timeout: N, throwOnTimeout: _ } = h != null ? h : {};
    let P = null;
    const M = [new Promise((z) => {
      P = G([n, c], ([H, $]) => {
        e !== (H === $) && (P == null || P(), z(H));
      }, {
        flush: g,
        deep: v,
        immediate: !0
      });
    })];
    return N != null && M.push(Le(N, _).then(() => m(n)).finally(() => (P == null || P(), m(n)))), Promise.race(M);
  }
  function i(c) {
    return t((h) => Boolean(h), c);
  }
  function a(c) {
    return r(null, c);
  }
  function o(c) {
    return r(void 0, c);
  }
  function d(c) {
    return t(Number.isNaN, c);
  }
  function s(c, h) {
    return t((g) => {
      const v = Array.from(g);
      return v.includes(c) || v.includes(m(c));
    }, h);
  }
  function u(c) {
    return f(1, c);
  }
  function f(c = 1, h) {
    let g = -1;
    return t(() => (g += 1, g >= c), h);
  }
  return Array.isArray(m(n)) ? {
    toMatch: t,
    toContains: s,
    changed: u,
    changedTimes: f,
    get not() {
      return ye(n, !e);
    }
  } : {
    toMatch: t,
    toBe: r,
    toBeTruthy: i,
    toBeNull: a,
    toBeNaN: d,
    toBeUndefined: o,
    changed: u,
    changedTimes: f,
    get not() {
      return ye(n, !e);
    }
  };
}
function ot(n) {
  return ye(n);
}
function lt(n, e, t = {}) {
  const {
    immediate: r = !0
  } = t, i = C(!1);
  let a = null;
  function o() {
    a && (clearTimeout(a), a = null);
  }
  function d() {
    i.value = !1, o();
  }
  function s(...u) {
    o(), i.value = !0, a = setTimeout(() => {
      i.value = !1, a = null, n(...u);
    }, m(e));
  }
  return r && (i.value = !0, be && s()), Ce(d), {
    isPending: i,
    start: s,
    stop: d
  };
}
function st(n) {
  var e;
  const t = m(n);
  return (e = t == null ? void 0 : t.$el) != null ? e : t;
}
const Se = be ? window : void 0;
function B(...n) {
  let e, t, r, i;
  if (nt(n[0]) || Array.isArray(n[0]) ? ([t, r, i] = n, e = Se) : [e, t, r, i] = n, !e)
    return rt;
  Array.isArray(t) || (t = [t]), Array.isArray(r) || (r = [r]);
  const a = [], o = () => {
    a.forEach((f) => f()), a.length = 0;
  }, d = (f, c, h) => (f.addEventListener(c, h, i), () => f.removeEventListener(c, h, i)), s = G(() => st(e), (f) => {
    o(), f && a.push(...t.flatMap((c) => r.map((h) => d(f, c, h))));
  }, { immediate: !0, flush: "post" }), u = () => {
    s(), o();
  };
  return Ce(u), u;
}
const me = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}, pe = "__vueuse_ssr_handlers__";
me[pe] = me[pe] || {};
me[pe];
function We(n, e = {}) {
  const {
    immediate: t = !0,
    window: r = Se
  } = e, i = C(!1);
  let a = null;
  function o() {
    !i.value || !r || (n(), a = r.requestAnimationFrame(o));
  }
  function d() {
    !i.value && r && (i.value = !0, o());
  }
  function s() {
    i.value = !1, a != null && r && (r.cancelAnimationFrame(a), a = null);
  }
  return t && d(), Ce(s), {
    isActive: i,
    pause: s,
    resume: d
  };
}
var ct = Object.defineProperty, ut = Object.defineProperties, dt = Object.getOwnPropertyDescriptors, Be = Object.getOwnPropertySymbols, ft = Object.prototype.hasOwnProperty, ht = Object.prototype.propertyIsEnumerable, Oe = (n, e, t) => e in n ? ct(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : n[e] = t, p = (n, e) => {
  for (var t in e || (e = {}))
    ft.call(e, t) && Oe(n, t, e[t]);
  if (Be)
    for (var t of Be(e))
      ht.call(e, t) && Oe(n, t, e[t]);
  return n;
}, E = (n, e) => ut(n, dt(e));
const yt = {
  json: "application/json",
  text: "text/plain",
  formData: "multipart/form-data"
};
function ae(n) {
  return at(n, "immediate", "refetch", "initialData", "timeout", "beforeFetch", "afterFetch", "onFetchError", "fetch");
}
function mt(n) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(n);
}
function Q(n) {
  return typeof Headers < "u" && n instanceof Headers ? Object.fromEntries([...n.entries()]) : n;
}
function j(n, ...e) {
  return n === "overwrite" ? async (t) => {
    const r = e[e.length - 1];
    return r !== void 0 && await r(t), t;
  } : async (t) => (await e.reduce((r, i) => r.then(async () => {
    i && (t = p(p({}, t), await i(t)));
  }), Promise.resolve()), t);
}
function pt(n = {}) {
  const e = n.combination || "chain", t = n.options || {}, r = n.fetchOptions || {};
  function i(a, ...o) {
    const d = ve(() => {
      const f = m(n.baseUrl), c = m(a);
      return f && !mt(c) ? gt(f, c) : c;
    });
    let s = t, u = r;
    return o.length > 0 && (ae(o[0]) ? s = E(p(p({}, s), o[0]), {
      beforeFetch: j(e, t.beforeFetch, o[0].beforeFetch),
      afterFetch: j(e, t.afterFetch, o[0].afterFetch),
      onFetchError: j(e, t.onFetchError, o[0].onFetchError)
    }) : u = E(p(p({}, u), o[0]), {
      headers: p(p({}, Q(u.headers) || {}), Q(o[0].headers) || {})
    })), o.length > 1 && ae(o[1]) && (s = E(p(p({}, s), o[1]), {
      beforeFetch: j(e, t.beforeFetch, o[1].beforeFetch),
      afterFetch: j(e, t.afterFetch, o[1].afterFetch),
      onFetchError: j(e, t.onFetchError, o[1].onFetchError)
    })), vt(d, u, s);
  }
  return i;
}
function vt(n, ...e) {
  var t;
  const r = typeof AbortController == "function";
  let i = {}, a = { immediate: !0, refetch: !1, timeout: 0 };
  const o = {
    method: "GET",
    type: "text",
    payload: void 0
  };
  e.length > 0 && (ae(e[0]) ? a = p(p({}, a), e[0]) : i = e[0]), e.length > 1 && ae(e[1]) && (a = p(p({}, a), e[1]));
  const {
    fetch: d = (t = Se) == null ? void 0 : t.fetch,
    initialData: s,
    timeout: u
  } = a, f = de(), c = de(), h = de(), g = C(!1), v = C(!1), N = C(!1), _ = C(null), P = ue(null), q = ue(null), M = ue(s), z = ve(() => r && v.value);
  let H, $;
  const ke = () => {
    r && H && H.abort();
  }, se = (F) => {
    v.value = F, g.value = !F;
  };
  u && ($ = lt(ke, u, { immediate: !1 }));
  const ee = async (F = !1) => {
    var T;
    se(!0), q.value = null, _.value = null, N.value = !1, H = void 0, r && (H = new AbortController(), H.signal.onabort = () => N.value = !0, i = E(p({}, i), {
      signal: H.signal
    }));
    const k = {
      method: o.method,
      headers: {}
    };
    if (o.payload) {
      const ne = Q(k.headers);
      o.payloadType && (ne["Content-Type"] = (T = yt[o.payloadType]) != null ? T : o.payloadType);
      const re = m(o.payload);
      k.body = o.payloadType === "json" ? JSON.stringify(re) : re;
    }
    let R = !1;
    const A = { url: m(n), options: p(p({}, k), i), cancel: () => {
      R = !0;
    } };
    if (a.beforeFetch && Object.assign(A, await a.beforeFetch(A)), R || !d)
      return se(!1), Promise.resolve(null);
    let L = null;
    return $ && $.start(), new Promise((ne, re) => {
      var Te;
      d(A.url, E(p(p({}, k), A.options), {
        headers: p(p({}, Q(k.headers)), Q((Te = A.options) == null ? void 0 : Te.headers))
      })).then(async (w) => {
        if (P.value = w, _.value = w.status, L = await w[o.type](), a.afterFetch && _.value >= 200 && _.value < 300 && ({ data: L } = await a.afterFetch({ data: L, response: w })), M.value = L, !w.ok)
          throw new Error(w.statusText);
        return f.trigger(w), ne(w);
      }).catch(async (w) => {
        let He = w.message || w.name;
        return a.onFetchError && ({ data: L, error: He } = await a.onFetchError({ data: L, error: w, response: P.value })), M.value = L, q.value = He, c.trigger(w), F ? re(w) : ne(null);
      }).finally(() => {
        se(!1), $ && $.stop(), h.trigger(null);
      });
    });
  }, Pe = fe(a.refetch);
  G([
    Pe,
    fe(n)
  ], ([F]) => F && ee(), { deep: !0 });
  const te = {
    isFinished: g,
    statusCode: _,
    response: P,
    error: q,
    data: M,
    isFetching: v,
    canAbort: z,
    aborted: N,
    abort: ke,
    execute: ee,
    onFetchResponse: f.on,
    onFetchError: c.on,
    onFetchFinally: h.on,
    get: I("GET"),
    put: I("PUT"),
    post: I("POST"),
    delete: I("DELETE"),
    patch: I("PATCH"),
    head: I("HEAD"),
    options: I("OPTIONS"),
    json: V("json"),
    text: V("text"),
    blob: V("blob"),
    arrayBuffer: V("arrayBuffer"),
    formData: V("formData")
  };
  function I(F) {
    return (T, k) => {
      if (!v.value) {
        o.method = F, o.payload = T, o.payloadType = k, Ie(o.payload) && G([
          Pe,
          fe(o.payload)
        ], ([A]) => A && ee(), { deep: !0 });
        const R = m(o.payload);
        return !k && R && Object.getPrototypeOf(R) === Object.prototype && (o.payloadType = "json"), E(p({}, te), {
          then(A, L) {
            return ce().then(A, L);
          }
        });
      }
    };
  }
  function ce() {
    return new Promise((F, T) => {
      ot(g).toBe(!0).then(() => F(te)).catch((k) => T(k));
    });
  }
  function V(F) {
    return () => {
      if (!v.value)
        return o.type = F, E(p({}, te), {
          then(T, k) {
            return ce().then(T, k);
          }
        });
    };
  }
  return a.immediate && setTimeout(ee, 0), E(p({}, te), {
    then(F, T) {
      return ce().then(F, T);
    }
  });
}
function gt(n, e) {
  return !n.endsWith("/") && !e.startsWith("/") ? `${n}/${e}` : `${n}${e}`;
}
var Ne;
(function(n) {
  n.UP = "UP", n.RIGHT = "RIGHT", n.DOWN = "DOWN", n.LEFT = "LEFT", n.NONE = "NONE";
})(Ne || (Ne = {}));
var bt = Object.defineProperty, Me = Object.getOwnPropertySymbols, Ct = Object.prototype.hasOwnProperty, St = Object.prototype.propertyIsEnumerable, ze = (n, e, t) => e in n ? bt(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : n[e] = t, Wt = (n, e) => {
  for (var t in e || (e = {}))
    Ct.call(e, t) && ze(n, t, e[t]);
  if (Me)
    for (var t of Me(e))
      St.call(e, t) && ze(n, t, e[t]);
  return n;
};
const Ft = {
  easeInSine: [0.12, 0, 0.39, 0],
  easeOutSine: [0.61, 1, 0.88, 1],
  easeInOutSine: [0.37, 0, 0.63, 1],
  easeInQuad: [0.11, 0, 0.5, 0],
  easeOutQuad: [0.5, 1, 0.89, 1],
  easeInOutQuad: [0.45, 0, 0.55, 1],
  easeInCubic: [0.32, 0, 0.67, 0],
  easeOutCubic: [0.33, 1, 0.68, 1],
  easeInOutCubic: [0.65, 0, 0.35, 1],
  easeInQuart: [0.5, 0, 0.75, 0],
  easeOutQuart: [0.25, 1, 0.5, 1],
  easeInOutQuart: [0.76, 0, 0.24, 1],
  easeInQuint: [0.64, 0, 0.78, 0],
  easeOutQuint: [0.22, 1, 0.36, 1],
  easeInOutQuint: [0.83, 0, 0.17, 1],
  easeInExpo: [0.7, 0, 0.84, 0],
  easeOutExpo: [0.16, 1, 0.3, 1],
  easeInOutExpo: [0.87, 0, 0.13, 1],
  easeInCirc: [0.55, 0, 1, 0.45],
  easeOutCirc: [0, 0.55, 0.45, 1],
  easeInOutCirc: [0.85, 0, 0.15, 1],
  easeInBack: [0.36, 0, 0.66, -0.56],
  easeOutBack: [0.34, 1.56, 0.64, 1],
  easeInOutBack: [0.68, -0.6, 0.32, 1.6]
};
Wt({
  linear: it
}, Ft);
const O = (n) => n === void 0;
function y(n, e) {
  const t = m(n);
  return O(t) ? e : Number(t);
}
function x(n, e) {
  const t = m(n);
  return Array.isArray(t) ? t : t ? String(t) : e;
}
function b(n, e) {
  const t = m(n);
  return O(t) ? e : String(t);
}
function S(n, e) {
  const t = m(n);
  return O(t) ? e : Boolean(t);
}
const le = {
  src: {
    type: String,
    default: null
  },
  audioControls: {
    type: Boolean,
    default: !0
  },
  corsAnonym: {
    type: Boolean,
    default: !1
  },
  canvWidth: {
    type: Number,
    default: 300
  },
  canvHeight: {
    type: Number,
    default: 80
  },
  canvFillColor: {
    type: [String, Array],
    default: ""
  },
  placeholder: {
    type: Boolean,
    default: !0
  }
}, wt = {
  barWidth: {
    type: Number,
    default: 5
  },
  barSpace: {
    type: Number,
    default: 1
  },
  barColor: {
    type: [String, Array],
    default: "#0A0AFF"
  },
  capsHeight: {
    type: Number,
    default: 0
  },
  capsDropSpeed: {
    type: Number,
    default: 0.9
  },
  capsColor: {
    type: String,
    default: "#A0A0FF"
  },
  brickHeight: {
    type: Number,
    default: 0
  },
  brickSpace: {
    type: Number,
    default: 1
  },
  symmetric: {
    type: Boolean,
    default: !1
  },
  fftSize: {
    type: Number,
    default: 1024
  }
}, W = { ...le, ...wt };
function _t() {
  return W;
}
class xe {
  constructor(e) {
    l(this, "barColor");
    l(this, "barSpace");
    l(this, "barWidth");
    l(this, "brickHeight");
    l(this, "brickSpace");
    l(this, "canvFillColor");
    l(this, "canvHeight");
    l(this, "canvWidth");
    l(this, "capsColor");
    l(this, "capsDropSpeed");
    l(this, "capsHeight");
    l(this, "fftSize");
    l(this, "frqBits");
    l(this, "placeholder");
    l(this, "symmetric");
    this.barColor = x(e.barColor, W.barColor.default), this.barSpace = y(e.barSpace, W.barSpace.default), this.brickHeight = y(e.brickHeight, W.brickHeight.default), this.brickSpace = y(e.brickSpace, W.brickSpace.default), this.canvFillColor = x(e.canvFillColor, W.canvFillColor.default), this.canvHeight = y(e.canvHeight, W.canvHeight.default), this.canvWidth = y(e.canvWidth, W.canvWidth.default), this.capsColor = b(e.capsColor, W.capsColor.default), this.capsDropSpeed = y(e.capsDropSpeed, W.capsDropSpeed.default), this.capsHeight = y(e.capsHeight, W.capsHeight.default), this.fftSize = y(e.fftSize, W.fftSize.default), this.frqBits = this.fftSize >> 1, this.placeholder = S(e.placeholder, W.placeholder.default), this.symmetric = S(e.symmetric, W.symmetric.default);
    const t = y(e.barWidth, W.barWidth.default);
    this.barWidth = t > this.canvWidth ? this.canvWidth : t;
  }
  alignSym(e) {
    return this.symmetric ? (this.canvHeight - e) / 2 : 0;
  }
}
const kt = {
  lineWidth: {
    type: Number,
    default: 2
  },
  lineColor: {
    type: [String, Array],
    default: "#9F9"
  },
  fftSize: {
    type: Number,
    default: 128
  }
}, je = { ...le, ...kt };
function Pt() {
  return je;
}
class Ee {
  constructor(e) {
    l(this, "canvWidth");
    l(this, "canvHeight");
    l(this, "canvFillColor");
    l(this, "lineWidth");
    l(this, "lineColor");
    l(this, "fftSize");
    l(this, "placeholder");
    const t = je;
    this.canvWidth = y(e.canvWidth, t.canvWidth.default), this.canvHeight = y(e.canvHeight, t.canvHeight.default), this.canvFillColor = x(e.canvFillColor, t.canvFillColor.default), this.lineWidth = y(e.lineWidth, t.lineWidth.default), this.lineColor = x(e.lineColor, t.lineColor.default), this.fftSize = y(e.fftSize, t.fftSize.default), this.placeholder = S(e.placeholder, t.placeholder.default);
  }
}
const Tt = {
  fftSize: {
    type: Number,
    default: 1024
  },
  canvWidth: {
    type: Number,
    default: 100
  },
  canvHeight: {
    type: Number,
    default: 100
  },
  radius: {
    type: Number,
    default: 0
  },
  lineWidth: {
    type: Number,
    default: 1
  },
  lineSpace: {
    type: Number,
    default: 1
  },
  outlineColor: {
    type: String,
    default: "#0000FF"
  },
  outlineWidth: {
    type: Number,
    default: 0.3
  },
  barWidth: {
    type: Number,
    default: 1
  },
  barLength: {
    type: Number,
    default: 0
  },
  barColor: {
    type: [String, Array],
    default: ["#FFFFFF", "#0000FF"]
  },
  progress: {
    type: Boolean,
    default: !0
  },
  progressWidth: {
    type: Number,
    default: 1
  },
  progressColor: {
    type: String,
    default: "#0000FF"
  },
  progressClockwise: {
    type: Boolean,
    default: !0
  },
  outlineMeterSpace: {
    type: Number,
    default: 3
  },
  playtime: {
    type: Boolean,
    default: !1
  },
  playtimeFont: {
    type: String,
    default: "14px Monaco"
  },
  playtimeColor: {
    type: String,
    default: "#00f"
  },
  rotateGraph: {
    type: Boolean,
    default: !1
  },
  rotateSpeed: {
    type: Number,
    default: 1e-3
  }
}, Ge = { ...le, ...Tt };
function Ht() {
  return Ge;
}
let ie = 1.5;
class De {
  constructor(e) {
    l(this, "barColor");
    l(this, "barLength");
    l(this, "barWidth");
    l(this, "canvFillColor");
    l(this, "canvHeight");
    l(this, "canvWidth");
    l(this, "fftSize");
    l(this, "lineSpace");
    l(this, "lineWidth");
    l(this, "outlineColor");
    l(this, "outlineMeterSpace");
    l(this, "outlineWidth");
    l(this, "placeholder");
    l(this, "playtime");
    l(this, "playtimeColor");
    l(this, "playtimeFont");
    l(this, "progress");
    l(this, "progressClockwise");
    l(this, "progressColor");
    l(this, "progressWidth");
    l(this, "radius");
    l(this, "rotateGraph");
    l(this, "rotateSpeed");
    const t = Ge;
    this.barColor = x(e.barColor, t.barColor.default), this.barLength = y(e.barLength, t.barLength.default), this.barWidth = y(e.barWidth, t.barWidth.default), this.canvFillColor = x(e.canvFillColor, t.canvFillColor.default), this.canvHeight = y(e.canvHeight, t.canvHeight.default), this.canvWidth = y(e.canvWidth, t.canvWidth.default), this.fftSize = y(e.fftSize, t.fftSize.default), this.lineSpace = y(e.lineSpace, t.lineSpace.default), this.lineWidth = y(e.lineWidth, t.lineWidth.default), this.outlineColor = b(e.outlineColor, t.outlineColor.default), this.outlineMeterSpace = y(e.outlineMeterSpace, t.outlineMeterSpace.default), this.outlineWidth = y(e.outlineWidth, t.outlineWidth.default), this.lineWidth = y(e.lineWidth, t.lineWidth.default), this.placeholder = S(e.placeholder, t.placeholder.default), this.playtime = S(e.playtime, t.playtime.default), this.playtimeColor = b(e.playtimeColor, t.playtimeColor.default), this.playtimeFont = b(e.playtimeFont, t.playtimeFont.default), this.progress = S(e.progress, t.progress.default), this.progressClockwise = S(e.progressClockwise, t.progressClockwise.default), this.progressColor = b(e.progressColor, t.progressColor.default), this.progressWidth = y(e.progressWidth, t.progressWidth.default), this.radius = y(e.radius, t.radius.default), this.rotateGraph = S(e.rotateGraph, t.rotateGraph.default), this.rotateSpeed = y(e.rotateSpeed, t.rotateSpeed.default);
  }
  get cx() {
    return this.canvWidth / 2;
  }
  get cy() {
    return this.canvHeight / 2;
  }
  get r() {
    return this.radius > 0 ? this.radius : Math.round(this.canvWidth / 2 * 0.7);
  }
  get arcStep() {
    return Math.ceil(this.lineWidth + this.lineSpace);
  }
  get barLen() {
    return this.barLength > 0 ? this.barLength : this.canvWidth / 2 - this.r;
  }
  get angle() {
    const e = () => ie === 3.5 ? 1.5 : ie + this.rotateSpeed;
    return ie = this.rotateGraph ? e() : 1.5, Math.PI * ie;
  }
}
const At = {
  canvWidth: {
    type: Number,
    default: 500
  },
  canvHeight: {
    type: Number,
    default: 80
  },
  playedLineWidth: {
    type: Number,
    default: 0.5
  },
  playedLineColor: {
    type: String,
    default: "navy"
  },
  noplayedLineWidth: {
    type: Number,
    default: 0.5
  },
  noplayedLineColor: {
    type: String,
    default: "lime"
  },
  playtime: {
    type: Boolean,
    default: !0
  },
  playtimeWithMs: {
    type: Boolean,
    default: !0
  },
  playtimeFontSize: {
    type: Number,
    default: 12
  },
  playtimeFontFamily: {
    type: String,
    default: "monospace"
  },
  playtimeFontColor: {
    type: String,
    default: "grey"
  },
  playtimeTextBottom: {
    type: Boolean,
    default: !1
  },
  playtimeSlider: {
    type: Boolean,
    default: !0
  },
  playtimeSliderColor: {
    type: String,
    default: "red"
  },
  playtimeSliderWidth: {
    type: Number,
    default: 1
  },
  playtimeClickable: {
    type: Boolean,
    default: !0
  },
  requester: {
    type: Function,
    default: fetch
  }
}, Ve = { ...le, ...At };
function Lt() {
  return Ve;
}
class Bt {
  constructor(e) {
    l(this, "src");
    l(this, "canvWidth");
    l(this, "canvHeight");
    l(this, "canvFillColor");
    l(this, "currentTime");
    l(this, "duration");
    l(this, "playedLineWidth");
    l(this, "playedLineColor");
    l(this, "noplayedLineWidth");
    l(this, "noplayedLineColor");
    l(this, "playtime");
    l(this, "playtimeWithMs");
    l(this, "playtimeFontSize");
    l(this, "playtimeFontFamily");
    l(this, "playtimeFontColor");
    l(this, "playtimeTextBottom");
    l(this, "playtimeSlider");
    l(this, "playtimeSliderColor");
    l(this, "playtimeSliderWidth");
    l(this, "playtimeClickable");
    l(this, "peaks", []);
    const t = Ve;
    this.canvWidth = y(e.canvWidth, t.canvWidth.default), this.canvHeight = y(e.canvHeight, t.canvHeight.default), this.canvFillColor = x(e.canvFillColor, t.canvFillColor.default), this.playedLineWidth = y(e.playedLineWidth, t.playedLineWidth.default), this.playedLineColor = b(e.playedLineColor, t.playedLineColor.default), this.noplayedLineWidth = y(e.noplayedLineWidth, t.noplayedLineWidth.default), this.noplayedLineColor = b(e.noplayedLineColor, t.noplayedLineColor.default), this.playtime = S(e.playtime, t.playtime.default), this.playtimeWithMs = S(e.playtimeWithMs, t.playtimeWithMs.default), this.playtimeFontSize = y(e.playtimeFontSize, t.playtimeFontSize.default), this.playtimeFontFamily = b(e.playtimeFontFamily, t.playtimeFontFamily.default), this.playtimeFontColor = b(e.playtimeFontColor, t.playtimeFontColor.default), this.playtimeTextBottom = S(e.playtimeTextBottom, t.playtimeTextBottom.default), this.playtimeSlider = S(e.playtimeSlider, t.playtimeSlider.default), this.playtimeSliderColor = b(e.playtimeSliderColor, t.playtimeSliderColor.default), this.playtimeSliderWidth = y(e.playtimeSliderWidth, t.playtimeSliderWidth.default), this.playtimeClickable = S(e.playtimeClickable, t.playtimeClickable.default), this.src = O(e.src) ? null : String(e.src), this.currentTime = 0, this.duration = 0;
  }
  get playX() {
    if (!this.duration)
      return 0;
    const e = ~~(this.currentTime / this.duration * this.canvWidth);
    return e > this.canvWidth ? this.canvWidth : e;
  }
  get timePlayed() {
    const e = [
      this.currentTime / 3600,
      this.currentTime / 60 % 60,
      this.currentTime % 60
    ].map((r) => String(~~r).padStart(2, "0")).join(":");
    if (!this.playtimeWithMs)
      return e;
    const t = ~~(this.currentTime % 1 * 1e3);
    return [e, String(t).padStart(3, "0")].join(".");
  }
  setPeaks(e) {
    this.peaks.slice(0);
    let t = 0, r = 0, i = 0, a = 0;
    const o = Math.ceil(e.length / this.canvWidth), d = this.canvWidth, s = this.canvHeight;
    for (let u = 0; u < e.numberOfChannels; u++) {
      const f = e.getChannelData(u);
      for (let c = 0; c < d; c++) {
        const h = ~~(c * o), g = ~~(h + o);
        t = 0, r = 0;
        for (let v = h; v < g; v++)
          t = f[v] < t ? f[v] : t, r = f[v] > r ? f[v] : r;
        this.peaks[c] && (this.peaks[c][0] = this.peaks[c][0] < r ? r : this.peaks[c][0], this.peaks[c][1] = this.peaks[c][1] > t ? t : this.peaks[c][1]), this.peaks[c] = [r, t];
      }
    }
    for (let u = 0; u < this.peaks.length; u++)
      r = this.peaks[u][0], t = this.peaks[u][1], i = s / 2 - r * s / 2, a = s / 2 - t * s / 2, this.peaks[u] = [i, a === i ? i + 1 : a];
  }
}
const Ot = {
  media: {
    type: Object,
    required: !1,
    default: null
  },
  canvWidth: {
    type: Number,
    default: 0
  },
  canvClass: {
    type: String,
    default: ""
  },
  canvHeight: {
    type: Number,
    default: 0
  },
  canvFillColor: {
    type: String,
    default: ""
  },
  circleGradient: {
    type: Array,
    default: [[0, "palegreen"], [0.3, "lime"], [0.7, "limegreen"], [1, "green"]]
  },
  fftSize: {
    type: Number
  },
  type: {
    type: String,
    default: "wform"
  },
  frequLnum: {
    type: Number,
    default: 60
  },
  frequLineCap: {
    type: Boolean,
    default: !1
  },
  frequDirection: {
    type: String,
    default: "lr"
  },
  lineColor: {
    type: String,
    default: "lime"
  },
  lineWidth: {
    type: Number
  },
  radius: {
    type: Number,
    default: 4
  },
  connectDestination: {
    type: Boolean,
    default: !1
  },
  vbarBgColor: {
    type: String,
    default: "#e1e1e1"
  },
  vbarCaps: {
    type: Boolean,
    default: !0
  },
  vbarSpace: {
    type: Number,
    default: 1
  },
  vbarWidth: {
    type: Number,
    default: 4
  },
  vbarFillColor: {
    type: String,
    default: "lime"
  },
  vbarRightColor: {
    type: String,
    default: "#c0c0c0"
  }
}, Re = { ...Ot };
function Nt() {
  return Re;
}
class he {
  constructor(e) {
    l(this, "canvWidth");
    l(this, "canvHeight");
    l(this, "canvFillColor");
    l(this, "canvClass");
    l(this, "circleGradient");
    l(this, "fftSize");
    l(this, "type");
    l(this, "frequLnum");
    l(this, "frequLineCap");
    l(this, "frequDirection");
    l(this, "lineColor");
    l(this, "lineWidth");
    l(this, "radius");
    l(this, "connectDestination");
    l(this, "vbarBgColor");
    l(this, "vbarCaps");
    l(this, "vbarFillColor");
    l(this, "vbarRightColor");
    l(this, "vbarSpace");
    l(this, "vbarWidth");
    const t = Re;
    this.canvFillColor = b(e.canvFillColor, t.canvFillColor.default), this.canvClass = b(e.canvClass, t.canvClass.default), this.circleGradient = O(e.circleGradient) ? t.circleGradient.default : e.circleGradient, this.type = b(e.type, t.type.default), this.fftSize = O(e.fftSize) ? this.type === "frequ" ? 1024 : 8192 : Number(e.fftSize), this.frequLnum = y(e.frequLnum, t.frequLnum.default), this.frequLineCap = S(e.frequLineCap, t.frequLineCap.default), this.frequDirection = b(e.frequDirection, t.frequDirection.default), this.lineColor = b(e.lineColor, t.lineColor.default), this.lineWidth = O(e.lineWidth) ? this.type === "frequ" ? 3 : 0.5 : Number(e.lineWidth), this.radius = y(e.radius, t.radius.default), this.connectDestination = S(e.connectDestination, t.connectDestination.default), this.vbarBgColor = b(e.vbarBgColor, t.vbarBgColor.default), this.vbarCaps = S(e.vbarCaps, t.vbarCaps.default), this.vbarFillColor = b(e.vbarFillColor, t.vbarFillColor.default), this.vbarRightColor = b(e.vbarRightColor, t.vbarRightColor.default), this.vbarSpace = y(e.vbarSpace, t.vbarSpace.default), this.vbarWidth = y(e.vbarWidth, t.vbarWidth.default), this.canvWidth = O(e.canvWidth) || Number(e.canvWidth) === 0 ? this.defaultWidth : Number(e.canvWidth), this.canvHeight = O(e.canvHeight) || Number(e.canvHeight) === 0 ? this.defaultHeight : Number(e.canvHeight);
  }
  get defaultWidth() {
    switch (this.type) {
      case "vbar":
        return 50;
      case "frequ":
        return 300;
      case "circle":
        return 80;
      default:
        return 200;
    }
  }
  get defaultHeight() {
    switch (this.type) {
      case "vbar":
        return 20;
      case "frequ":
        return 80;
      case "circle":
        return 80;
      default:
        return 40;
    }
  }
}
function Fe(n, e, t) {
  let r = null, i = null, a = null;
  const o = e || 1024, d = new Uint8Array(o / 2), { pause: s, resume: u } = We(() => {
    !i || (i.getByteFrequencyData(d), t(d));
  }, { immediate: !1 });
  B(n, "play", () => {
    const f = m(n);
    !f || (r || (r = new AudioContext(), a = r.createMediaElementSource(f)), i = r.createAnalyser(), i.fftSize = o, a == null || a.connect(i), i.connect(r.destination), r.resume(), u());
  }), B(n, "pause", () => {
    r == null || r.suspend(), a == null || a.disconnect(), i == null || i.disconnect(), s();
  });
}
function Z(n, e) {
  const t = C(null);
  return ge(() => {
    const r = m(n);
    !r || (t.value = r.getContext("2d"), r.width = e.canvWidth, r.height = e.canvHeight);
  }), t;
}
function we(n, e, t, r) {
  n.clearRect(0, 0, e, t), r && (n.fillStyle = _e(n, e, t, r), n.fillRect(0, 0, e, t));
}
function _e(n, e, t, r) {
  if (!Array.isArray(r))
    return r || "";
  const i = n.createLinearGradient(e / 2, 0, e / 2, t);
  let a = 0;
  return r.forEach((o) => {
    i.addColorStop(a, o), a += 1 / r.length;
  }), i;
}
const X = Array(16).fill(0);
function Mt(n, e, t) {
  const r = new xe(t);
  X.length = r.fftSize / 2, X.fill(0);
  const i = Z(e, r);
  B(n, "loadedmetadata", () => {
    !r.placeholder || !i || qe(new Uint8Array(r.fftSize / 2), i, t);
  }), Fe(n, r.fftSize, (a) => {
    qe(a, i, t);
  });
}
function qe(n, e, t) {
  const r = m(e);
  if (!r)
    return;
  const i = new xe(t), a = Math.round((i.barWidth + i.barSpace) / i.frqBits * i.canvWidth), o = n.length;
  let d = 0;
  we(r, i.canvWidth, i.canvHeight, i.canvFillColor);
  for (let s = 0; s < o; s++) {
    if (s % a)
      continue;
    const u = Math.round(n.slice(s, s + a).reduce((c, h) => h + c, 0) / a), f = u / 255 * i.canvHeight;
    zt(r, i, u, s, d), r.fillStyle = _e(r, i.canvWidth, i.canvHeight, i.barColor), i.brickHeight > 0 ? Et(r, i, f, d) : r.fillRect(d, i.canvHeight - f - i.alignSym(f), i.barWidth, f), d += i.barWidth + i.barSpace;
  }
}
function zt(n, e, t, r, i) {
  if (e.capsHeight === 0)
    return;
  const a = X[r] <= t ? t : X[r] - e.capsDropSpeed;
  X[r] = a;
  const o = a / 255 * e.canvHeight, d = e.canvHeight - o - e.capsHeight - e.alignSym(o);
  n.fillStyle = e.capsColor, n.fillRect(i, d, e.barWidth, e.capsHeight), e.symmetric && n.fillRect(i, e.canvHeight - d - e.capsHeight, e.barWidth, e.capsHeight);
}
function Et(n, e, t, r) {
  for (let i = 0; i < t; i += e.brickHeight + e.brickSpace)
    n.fillRect(
      r,
      e.canvHeight - t + i - e.alignSym(t),
      e.barWidth,
      e.brickHeight
    );
}
const Dt = ["controls", "src"], qt = /* @__PURE__ */ Y({
  __name: "AVBars",
  props: _t(),
  setup(n) {
    const e = n, t = C(null), r = C(null);
    return Mt(t, r, e), (i, a) => (J(), K(oe, null, [
      D("audio", {
        ref_key: "player",
        ref: t,
        controls: e.audioControls,
        src: e.src
      }, null, 8, Dt),
      D("canvas", {
        ref_key: "canvas",
        ref: r
      }, null, 512)
    ], 64));
  }
});
function $t(n, e, t) {
  const r = new De(t), i = Z(e, r);
  B(n, "loadedmetadata", () => {
    xt(i, r);
  }), Fe(n, r.fftSize, (a) => {
    It(a, i, n, new De(t));
  });
}
function It(n, e, t, r) {
  const i = m(e);
  if (!i)
    return;
  const a = m(t);
  if (!a)
    return;
  const o = n.length, d = (r.lineWidth + r.lineSpace) / o * (2 * Math.PI);
  we(i, r.canvWidth, r.canvHeight, r.canvFillColor), Ue(i, r), jt(i, a, r), Gt(i, a, r), i.lineWidth = r.barWidth, i.strokeStyle = Vt(i, r);
  let s = r.angle;
  for (let u = 0; u < o; u++) {
    if (s += d, u % r.arcStep)
      continue;
    const f = Math.round(n.slice(u, u + r.arcStep).reduce((h, g) => g + h, 0) / r.arcStep), c = r.r + f / 255 * r.barLen;
    i.beginPath(), i.moveTo(r.r * Math.cos(s) + r.cx, r.r * Math.sin(s) + r.cy), i.lineTo(c * Math.cos(s) + r.cx, c * Math.sin(s) + r.cy), i.stroke();
  }
}
function xt(n, e) {
  const t = m(n);
  !t || (Ue(t, e), Qe(t, "0:00", e));
}
function Ue(n, e) {
  e.outlineWidth !== 0 && (n.beginPath(), n.strokeStyle = e.outlineColor, n.lineWidth = e.outlineWidth, n.arc(e.cx, e.cy, e.r, 0, 2 * Math.PI), n.stroke());
}
function jt(n, e, t) {
  if (!t.progress)
    return;
  const { currentTime: r, duration: i } = e, a = r / i * 2 * Math.PI, o = Math.PI * 1.5 + a;
  !a || (n.lineWidth = t.progressWidth, n.strokeStyle = t.progressColor, n.beginPath(), n.arc(
    t.cx,
    t.cy,
    t.r - t.outlineWidth - t.outlineMeterSpace,
    1.5 * Math.PI,
    o,
    t.progressClockwise
  ), n.stroke());
}
function Gt(n, e, t) {
  const { currentTime: r } = e, i = Math.floor(r / 60), a = Math.floor(r) % 60, o = a < 10 ? `0${a}` : `${a}`, d = `${i}:${o}`;
  Qe(n, d, t);
}
function Qe(n, e, t) {
  n.font = t.playtimeFont, n.fillStyle = t.playtimeColor, n.textAlign = "center", n.fillText(e, t.cx, t.cy + parseInt(t.playtimeFont) * 0.25);
}
function Vt(n, e) {
  if (!Array.isArray(e.barColor))
    return e.barColor;
  const t = n.createRadialGradient(e.cx, e.cy, e.canvWidth / 2, e.cx, e.cy, 0);
  let r = 0;
  return e.barColor.forEach((i) => {
    t.addColorStop(r, i), r += 1 / e.barColor.length;
  }), t;
}
const Rt = ["controls", "src"], Ut = /* @__PURE__ */ Y({
  __name: "AVCircle",
  props: Ht(),
  setup(n) {
    const e = n, t = C(null), r = C(null);
    return $t(t, r, e), (i, a) => (J(), K(oe, null, [
      D("audio", {
        ref_key: "player",
        ref: t,
        controls: e.audioControls,
        src: e.src
      }, null, 8, Rt),
      D("canvas", {
        ref_key: "canvas",
        ref: r
      }, null, 512)
    ], 64));
  }
});
function Qt(n, e, t) {
  const r = new Ee(t), i = Z(e, r);
  G(i, () => {
    !r.placeholder || !m(i) || $e(new Uint8Array(r.fftSize), i, r);
  }), Fe(n, r.fftSize, (a) => {
    $e(a, i, new Ee(t));
  });
}
function $e(n, e, t) {
  const r = m(e);
  if (!r)
    return;
  const i = t.canvWidth, a = t.canvHeight, o = t.lineWidth, d = n.length, s = ~~i / 2 / d;
  let u = 0;
  const f = () => {
    let c = 0;
    for (let h = 0; h < d; h++) {
      const g = n[h];
      c = a * (255 - g) / 510, h % 2 && (c = a - c), r.lineTo(u, c), u += s;
    }
    return u;
  };
  we(r, i, a, t.canvFillColor), r.lineWidth = o, r.strokeStyle = _e(r, i, a, t.lineColor), r.beginPath(), n.reverse(), r.moveTo(u, a / 2), u = f(), n.reverse(), f(), r.lineTo(i, a / 2), r.stroke();
}
const Xt = ["controls", "src"], Yt = /* @__PURE__ */ Y({
  __name: "AVLine",
  props: Pt(),
  setup(n) {
    const e = n, t = C(null), r = C(null);
    return Qt(t, r, e), (i, a) => (J(), K(oe, null, [
      D("audio", {
        ref_key: "player",
        ref: t,
        controls: e.audioControls,
        src: e.src
      }, null, 8, Xt),
      D("canvas", {
        ref_key: "canvas",
        ref: r
      }, null, 512)
    ], 64));
  }
});
function Jt(n, e, t, r = {}) {
  const i = new Bt(t), a = Z(e, i);
  Kt(a, i, r);
  const { pause: o, resume: d } = We(() => {
    var s, u;
    i.currentTime = (u = (s = n == null ? void 0 : n.value) == null ? void 0 : s.currentTime) != null ? u : 0, U(a, i);
  }, { immediate: !1 });
  B(n, "play", d), B(n, "pause", o), B(n, "ended", () => {
    const s = m(n);
    !s || s.duration === i.duration || (i.duration = s.duration, U(a, i));
  }), B(n, "timeupdate", () => {
    const s = m(n);
    !s || (i.currentTime = s.currentTime, U(a, i));
  }), B(e, "click", (s) => {
    if (!i.playtimeClickable)
      return;
    const u = m(n);
    !u || (u.currentTime = s.offsetX / i.canvWidth * i.duration, i.currentTime = u.currentTime, U(a, i));
  });
}
function U(n, e) {
  const t = m(n);
  if (!t)
    return;
  let r = 0;
  t.clearRect(0, 0, e.canvWidth, e.canvHeight);
  const i = (a, o, d, s) => {
    for (t.lineWidth = d, t.strokeStyle = s, o = o > e.peaks.length ? e.peaks.length : o, t.beginPath(); a < o; a++)
      t.moveTo(a, e.peaks[a][0]), t.lineTo(a, e.peaks[a][1]);
    return t.stroke(), a;
  };
  r = i(r, e.playX, e.playedLineWidth, e.playedLineColor), i(r, e.peaks.length, e.noplayedLineWidth, e.noplayedLineColor), Xe(t, e), e.playtime && Ye(t, e);
}
function Xe(n, e) {
  n.lineWidth = e.playtimeSliderWidth, n.strokeStyle = e.playtimeSliderColor, n.beginPath(), n.moveTo(e.playX, 0), n.lineTo(e.playX, e.canvHeight), n.stroke();
}
function Ye(n, e) {
  const t = e.timePlayed, r = 3, i = ~~n.measureText(t).width, a = e.playX > e.canvWidth - i - r ? e.playX - i - r : e.playX + r, o = e.playtimeTextBottom ? e.canvHeight - e.playtimeFontSize + r : e.playtimeFontSize + r;
  n.fillStyle = e.playtimeFontColor, n.font = `${e.playtimeFontSize}px ${e.playtimeFontFamily}`, n.fillText(t, a, o);
}
function Kt(n, e, t) {
  if (!e.src)
    return;
  pt(t)(e.src).arrayBuffer().then(({ error: i, data: a }) => {
    const o = m(i);
    if (o !== null) {
      console.error(`Failed get url '${e.src}': ${o}`);
      return;
    }
    if (a.value === null) {
      console.error("invalid arrayBuffer data received");
      return;
    }
    new AudioContext().decodeAudioData(a.value).then((s) => {
      e.duration = s.duration, e.setPeaks(s), U(n, e);
    }).catch((s) => {
      console.error("Failed to decode audio array buffer:", s);
    });
  }), ge(() => {
    const i = m(n);
    !i || (i.lineWidth = e.noplayedLineWidth, i.strokeStyle = e.noplayedLineColor, i.beginPath(), i.moveTo(0, e.canvHeight / 2), i.lineTo(e.canvWidth, e.canvHeight / 2), i.stroke(), Xe(i, e), e.playtime && Ye(i, e));
  });
}
const Zt = ["controls", "src"], en = /* @__PURE__ */ Y({
  __name: "AVWaveform",
  props: Lt(),
  setup(n) {
    const e = n, t = C(null), r = C(null);
    return Jt(t, r, e, {
      options: { refetch: !0 },
      fetchOptions: { mode: "cors" }
    }), (i, a) => (J(), K(oe, null, [
      D("audio", {
        ref_key: "player",
        ref: t,
        controls: e.audioControls,
        src: e.src
      }, null, 8, Zt),
      D("canvas", {
        ref_key: "canvas",
        ref: r
      }, null, 512)
    ], 64));
  }
});
function tn(n, e) {
  const t = e;
  let r;
  const i = Z(n, new he(t)), { pause: a, resume: o } = We(() => {
    !r || rn(r, i, new he(t));
  }, { immediate: !1 });
  ge(() => {
    const d = m(t.media);
    d ? (r = nn(d, new he(t)), o()) : a();
  });
}
function nn(n, e) {
  const t = new AudioContext(), r = t.createAnalyser();
  return t.createMediaStreamSource(n).connect(r), r.fftSize = e.fftSize, e.connectDestination && r.connect(t.destination), r;
}
function rn(n, e, t) {
  const r = m(e);
  if (!r)
    return;
  const i = new Uint8Array(n.fftSize);
  switch (t.canvFillColor && (r.fillStyle = t.canvFillColor), r.clearRect(0, 0, t.canvWidth, t.canvHeight), r.beginPath(), r.strokeStyle = t.lineColor, t.type) {
    case "frequ":
      n.getByteFrequencyData(i), an(i, r, t);
      break;
    case "circle":
      n.getByteFrequencyData(i), ln(i, r, t);
      break;
    case "vbar":
      n.getByteFrequencyData(i), on(i, r, t);
      break;
    default:
      n.getByteTimeDomainData(i), sn(i, r, t);
      break;
  }
}
function an(n, e, t) {
  const r = t.frequDirection === "mo", i = r ? t.canvWidth / 2 : 0, a = r ? t.frequLnum / 2 : t.frequLnum, o = r ? t.canvWidth / a / 2 : t.canvWidth / a, d = t.canvHeight, s = t.lineWidth || 2;
  for (let u = 0; u < a; u++) {
    const f = r ? u * o : u * o + s, c = n.slice(f, f + o).reduce((g, v) => g + v / 255 * d, 0) / o, h = (d - c) / 2 + 2;
    e.lineWidth = s, e.lineCap = t.frequLineCap ? "round" : "butt", e.moveTo(i + f, h), e.lineTo(i + f, d - h), e.stroke(), r && u > 0 && (e.moveTo(i - f, h), e.lineTo(i - f, d - h), e.stroke());
  }
}
function on(n, e, t) {
  const r = t.vbarWidth, i = t.vbarSpace, a = r < 5 ? 5 : r / 2;
  let o = 0;
  for (let s = 0; s < n.length; s++)
    o = o < n[s] ? n[s] : o;
  const d = o / 255 * t.canvWidth;
  e.lineWidth = t.vbarWidth, e.lineCap = t.vbarCaps ? "round" : "butt", e.fillStyle = t.vbarBgColor, e.fillRect(0, 0, t.canvWidth, t.canvHeight);
  for (let s = r / 2; s + r + i <= t.canvWidth; s = s + r + i)
    e.strokeStyle = s > d ? t.vbarRightColor : t.vbarFillColor, e.beginPath(), e.moveTo(s, a), e.lineTo(s, t.canvHeight - a), e.stroke();
}
function ln(n, e, t) {
  const r = t.canvWidth / 2, i = t.canvHeight / 2, a = r < i ? r : i, d = Math.max(...n) / 255 * a, s = e.createRadialGradient(r, i, 0, r, i, d);
  for (const [u, f] of t.circleGradient)
    s.addColorStop(u, f);
  e.fillStyle = s, e.arc(r, i, d, 0, 2 * Math.PI), e.fill("evenodd");
}
function sn(n, e, t) {
  const r = t.canvHeight, i = t.canvWidth / t.fftSize;
  let a = 0;
  e.lineWidth = t.lineWidth || 0.5;
  for (let o = 0; o < n.length; o++) {
    const s = n[o] / 255 * r;
    e.lineTo(a, s), a += i;
  }
  e.stroke();
}
const cn = /* @__PURE__ */ Y({
  __name: "AVMedia",
  props: Nt(),
  setup(n) {
    const e = n, t = C(null);
    return tn(t, e), (r, i) => (J(), K("canvas", {
      ref_key: "canvas",
      ref: t
    }, null, 512));
  }
}), fn = {
  install(n) {
    n.component("av-bars", qt), n.component("av-circle", Ut), n.component("av-line", Yt), n.component("av-waveform", en), n.component("av-media", cn);
  }
};
export {
  qt as AVBars,
  Ut as AVCircle,
  Yt as AVLine,
  cn as AVMedia,
  fn as AVPlugin,
  en as AVWaveform,
  Mt as useAVBars,
  $t as useAVCircle,
  Qt as useAVLine,
  tn as useAVMedia,
  Jt as useAVWaveform
};
